<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>reveal.js - The HTML Presentation Framework</title>

  <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/custom-night.css" id="theme">

  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/custom-atom-one-dark.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>Meet React Server</h2>
          <h4>Blazing fast page load</h4>
          <h4>buttery-smooth navigation</h4>
          <img src="images/reactserver_logomark%402x.png" />
          <p>
            <small>Created by <a href="http://dougwade.io">Doug Wade</a> / <a href="http://twitter.com/AShedOfTools">@AShedOfTools</a></small>
          </p>

          <aside class="notes">
            <ul>
              <li>Thank Max Stoiber for the intro to css</li>
              <li>Express excitement to be in Amsterdam</li>
              <li>Going to talk about my favorite FOSS project, though we'll see after James Kyle's talk ;)</li>
          </aside>
        </section>

        <section>
          <h2>What's wrong?</h2>
          <h4>Javascript Fatigue</h4>
          <img style="max-width: 65%" src="images/js-fatigue.png" />

          <aside class="notes">
            <ul>
              <li>There are too many tools, and they change too often.</li>
              <li>The tooling is complicated to set up, and inaccessible for "joe and jane developer".</li>
              <li>it took us many months/tries/mistakes to get a universal react app working well.</li>
          </aside>
        </section>

        <section>
          <h2>What's wrong?</h2>
          <h4>Slow Internet</h4>
          <img style="max-width: 75%" src="/images/mobile-vs-fixed.png" />

          <aside class="notes">
            <ul>
              <li>From the The International Telecommunication Union, a branch of the UN</li>
              <li>Most internet users are on mobile.</li>
              <li>Most internet users are not in the first world.</li>
              <li>Most internet users don't have the patience to wait while your 4 MB bundle downloads</li>
              <li>(47% of consumers expect a web page to load in 2 seconds or less).</li>
          </aside>
        </section>

        <section>
          <h2>What's wrong?</h2>
          <h4>No Javascript</h4>
          <img src="/images/no-js.jpg" />

          <aside class="notes">
            <ul>
              <li>Primarily an SEO problem.</li>
              <li>Some users blocking because of ads or security.</li>
              <li>Has the added benefit of maintaining the "document" nature of the web</li>
          </aside>
        </section>

        <section>
          <h2>React Server</h2>
          <h4>Batteries-included framework for universal react applications and
            an ecosystem of associated build tools and middleware</h4>

          <aside class="notes">
            <ul>
              <li>An Express middleware</li>
              <li>Includes an associated build toolchain built on webpack</li>
              <li>A constellation of modules in a monorepo that evolves together built with Lerna</li>
              <li><i>just works</i> for beginners (addresses js fatigue)</li>
              <li>customizable (custom webpack config, custom express middleware) for advanced users</li>
          </aside>
        </section>

        <section>
          <h2>Server-side + SPA</h2>
          <p>Server-side rendering for the first load</p>
          <p>Client-side rendering for subsequent loads</p>

          <aside class="notes">
            <ul>
              <li>Addresses slow and js-free internet</li>
              <li>Do a server-render for the intial page load to get html content fast with no client js</li>
              <li>Load the code for rendering subsequent pages to get blazing fast page loads afterwards with only incremental data</li>
          </aside>
        </section>

        <section>
          <img src="images/shamwow.jpg" />
        </section>

        <section>
          <h2>Buttery smooth page loads</h2>
          <p>Break up the page into logical sections<p>
          <p>Stream them as soon as they are ready<p>

          <aside class="notes">
            <ul>
              <li>Address impatient users by getting chunks on the page as soon as possible</li>
              <li>Prevent users from clicking on the wrong element when the page "jumps" (Dark Pattern)</li>
              <li>Treat the page like a document that "snaps in" as soon as it is ready</li>
              <li>The page becomes interactive as soon as above-the-fold content is loaded but no sooner</li>
          </aside>
        </section>

        <section>
          <h2>Blazing fast</h2>
          <p>Precalculate data before client transitions with data bundling</p>
          <p>Ensure that you render the same markup to avoid page jank</p>

          <aside class="notes"/>
            <ul>
              <li>Send a bundle of data + code that was used for server rendering so the DOM render the same.</li>
              <li>client-side rendering "prequests" that the server ready a data bundle and hold it until the request</li>
            </ul>
          <aside>
        </section>

        <section>
          <h2>Be kind to your backend server</h2>
          <p>Send late arrivals in a script tag to avoid making the same request
            on the server and in the browser</p>

          <aside class="notes">
            <ul>
              <li>wait for a struggling backend, users might refresh the page or bounce</li>
              <li>If we send a partial on a timeout, it doubles the load on the server by making the same requests again</li>
              <li>Instead: leave the http connection open to the browser, and push down late arrivals in script tags</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Page Api</h2>
          <h4>Create pages, endpoints and middleware</h4>
          <pre><code>
// routes.js
module.exports = {
  routes: {
    reactnlpage: {
      path: ['/'],
      method: 'get',
      page: './reactnl'
    }
  }
}

// reactnl.js
export default class ReactNlPage {
  // lifecycle methods go here
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>The page api is the heart of react server, shared by data endpoints, pages, and middleware</li>
              <li>The routes file links pages, endpoints and middleware to a router</li>
              <li>Pages are classes with lifecycle methods<li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Page Api</h2>
          <p>lifecycle methods</p>

          <pre><code>
export default class ReactNlPage {
  getTitle() {
    return "ReactNl page"
  }

  getMetaTags() {
    return [
      { name: "example", content: "talk up React Server" },
    ];
  }
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>Lifecycle methods are specially named methods that React Server calls as part of the page lifecycle</li>
              <li>React Server provides "best-guess" defaults for all lifecycle methods</li>
              <li>This example adds meta tags and a title to the page head</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Page Api</h2>
          <p>Elements and routes</p>

          <pre><code>
let param;
export default class ReactNlPage {
  handleRoute(next) {
    param = this.getRequest().getQuery().param;
    return next();
  }

  getElements() {
    return (&lth1&gtGot param {param}&lt/h1&gt);
  }
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>HandleRoute is called when the route is resolved and determines http status code</li>
              <li>getElements gets the contents of the body tag</li>
              <li>This example retrieves a param from the url and displays it in an h1</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Page Api</h2>
          <p>scripts and stylesheets</p>

          <pre><code>
export default class ReactNlPage {
  getHeadStylesheets() {
    return [
      "/styles/example.css"
    ]
  }

  getBodyClasses() {
    return ["responsive-page", "typography"];
  }

  getScripts() {
    return [
      "/scripts/tracking.js"
    ]
  }
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>External synchronous js file can significantly impact perf by blocking</li>
              <li>devs define css + js in a structured way so they can't tank perf</li>
              <li>prepares us for http2 by creating a manifest of js + css to push<li>
              <li>body classes allow you to add classes to the generated body tag</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>RootElement, RootContainer and TheFold</h2>
          <pre><code>
export default class ReactNlPage {
  getElements() {
    return (
      &ltRootContainer&gt
        &ltRootElement&gt
          &ltHeader /&gt
        &lt/RootElement&gt
        &ltRootElement when={getMainContentData()}&gt
          &ltMainContent /&gt
        &lt/RootElement&gt
        &ltTheFold/&gt
        &ltRootElement when={getSeoContentData()}&gt
          &ltSeoContent /&gt
        &lt/RootElement
       &ltFooter/&gt
      &lt/RootContainer&gt);
  }
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>header without any data is emitted immediately</li>
              <li>main content is emitted when header data is resolved</li>
              <li>The fold emits a script tag that makes the content currently on page interactive</li>
              <li>seo content and the footer are emitted when getSeoContentData promise resolves</li>
              <li>The footer and header are rendered first, but footer is held back to avoid page jank</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Client Transitions</h2>
          <h4>With Link</h4>
          <pre><code>
&ltLink path={path} bundleData={true}&gt...&lt/Link&gt
          </code></pre>

          <h4>Frameback</h4>
          <pre><code>
&ltLink path={path} frameback={true} reuseFrame={true}&gt...&lt/Link&gt
          </code></pre>

          <h4>Or with navigateTo</h4>
          <pre><code>
navigateTo(path, {bundleData: true});
          </code></pre>
        </section>

        <section>
          <h2>Request Local Storage</h2>
          <p>Keep context on a single request</p>
          <pre><code>
import {getCurrentRequestContext} from "react-server";
const response = getCurrentRequestContext().getServerStash().res;
const path = getCurrentRequestContext().getCurrentPath();
          </code></pre>

          <aside class="notes">
            <ul>
              <li>Request Local Storage creates a storage object unique to a request</li>
              <li>Exposes large parts of the React Server Api</li>
              <li>For example: attach a request id to track errors emitted in deeply nested callbacks</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>React Server Agent</h2>
          <h4>Make and cache requests</h4>
          <pre><code>
import {ReactServerAgent} from 'react-server';
export default class ReactNlPage {
  handleRoute(next) {
    this.promise = ReactServerAgent
      .get("/api/endpoint")
      .then(res => res.body);
  }

  getElements() {
    return (&ltRootElement when={this.promise}&gt
      &ltEndpointConsumer /&gt
    &lt/RootElement&gt);
  }
}
          </code></pre>

          <aside class="notes">
            <ul>
              <li>RSA is SuperAgent and has methods for normal http verbs: get, head, del, patch, post and put</li>
              <li>Wrapped in a caching layer</li>
              <li>Allows extension with plugResponse and plugRequest</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Navigator</h2>
          <p>Keep track of navigation and history</p>
          <pre><code>
import {getCurrentRequestContext} from "react-server";
const navigator = getCurrentRequestContext();

navigator.on("navigateStart", onNavigateStart);
navigator.on("page", onPage);
navigator.on("navigateDone", onNavigateDone);
navigator.on("loadComplete", onLoadComplete);
          </code></pre>

          <aside class="notes">
            <ul>
              <li>The navigator gives access to the event lifecycle of client transitions</li>
              <li>The events are emitted in the order listed</li>
          </aside>
        </section>

        <section>
          <h2>A great dx</h2>
          <h4>A cli that handles</h4>
          <ul>
            <li>Generating a new project</li>
            <li>Code splitting</li>
            <li>module tagging</li>
            <li>hot reloading</li>
          </ul>

          <aside class="notes">
            <ul>
              <li>Code splitting is done with the SERVER_SIDE constant provided at compile time</li>
              <li>Module tagging is used to know from what module log lines are emitted</li>
              <li>hot reloading is started from the cli using the --hot flag</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>What's next?</h2>
          <ul>
            <li>Clustering</li>
            <li>Multi-site support</li>
            <li>RootProvider for Redux</li>
            <li>http 2</li>
          </ul>

          <aside class="notes">
            <ul>
              <li>Using pm2 for clustering works, but a clustering api w/ the module tagger for ipc allows better control of workers</li>
              <li>add starting multilple sites together as a first class abstraction to improve stats collection</li>
              <li>add better support for Redux by adding a RootProvider to avoid forcing a refresh on state change to synchronize stores</li>
              <li>renderScripts and renderHeadStylesheets mean upgrading to http2 without changes to client code</li>
          </aside>
        </section>

        <section>
          <h2>Just focus on writing components and managing state<h2>
          <h3>React Server handles the rest</h3>

          <pre><code>
$ npm install -g react-server-cli # OR yarn global add react-server-cli
$ react-server init
$ react-server add-page '/' Homepage
$ react-server start
          </code></pre>

          <aside class="notes">
            Advanced users can get ahold of their express instance and webpack config themselves and have full power.
          </aside>
        </section>

        <section style="text-align: left;">
          <h2>Questions?</h2>
          <p>
            - <a href="http://react-server.io">Check out the docs site</a> <br>
            - <a href="https://react-server.slack.com/">Chat with us on Slack</a> <br>
            - <a href="https://github.com/redfin/react-server">Fork us on github</a> <br>
            - <a href="https://github.com/hakimel/reveal.js">Slides made with Reveal.js</a>
          </p>

          <aside class="notes">
            The documentation site is the best resource -- it has the docs and is the most sophisticated example site
          </aside>
        </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [{
        src: 'lib/js/classList.js',
        condition: function() {
          return !document.body.classList;
        }
      }, {
        src: 'plugin/markdown/marked.js',
        condition: function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src: 'plugin/markdown/markdown.js',
        condition: function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src: 'plugin/highlight/highlight.js',
        async: true,
        condition: function() {
          return !!document.querySelector('pre code');
        },
        callback: function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src: 'plugin/zoom-js/zoom.js',
        async: true
      }, {
        src: 'plugin/notes/notes.js',
        async: true
      }]
    });
  </script>

</body>

</html>
